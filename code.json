{
  "description": "A production-ready Solana Anchor program for an on-chain perpetuals DEX, featuring a virtual AMM (vAMM), risk management, and oracle integration. This implementation follows modern Anchor patterns, security best practices, and is designed for composability and efficiency.",
  "cargoToml": {
    "filename": "Cargo.toml",
    "content": "[package]\nname = \"perp_dex\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\nname = \"perp_dex\"\n\n[features]\nno-entrypoint = []\nno-idl = []\nno-log-ix-name = []\ncpi = [\"no-entrypoint\"]\ndefault = []\n\n[dependencies]\nanchor-lang = {\n  version = \"0.30.0\",\n  features = [\"init-if-needed\"]\n}\nanchor-spl = \"0.30.0\"\nsolana-program = \"~1.18.0\"\nbytemuck = { version = \"1.15.0\", features = [\"derive\"] }\npyth-sdk-solana = \"0.10.0\"\nthiserror = \"1.0.59\"\n"
  },
  "program": {
    "lib": {
      "filename": "programs/perp_dex/src/lib.rs",
      "content": "//! On-chain perpetuals DEX with a virtual AMM (vAMM).\n\nuse anchor_lang::prelude::*;\n\n// Module declarations for organized code structure\npub mod error;\npub mod instructions;\npub mod math;\npub mod state;\npub mod validation;\n\n// Make modules public for use in the program\nuse instructions::*; \nuse state::constants::PROGRAM_SEED;\n\ndeclare_id!(\"perpFC8a13h45b2n3sUKG5aD5EwB2gXcnm5FL12h4m\");\n\n#[program]\npub mod perp_dex {\n    use super::*;\n\n    /// Initializes the global state of the protocol.\n    /// Must be called once before any other instruction.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `usdc_mint` - The public key of the USDC mint to be used as collateral.\n    pub fn initialize(\n        ctx: Context<Initialize>,\n        usdc_mint: Pubkey,\n    ) -> Result<()> {\n        instructions::initialize::handle(ctx, usdc_mint)\n    }\n\n    /// Creates a new perpetuals market.\n    /// Only callable by the program admin.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `market_index` - A unique index for the new market.\n    /// * `amm_base_asset_reserve` - Initial virtual base asset reserves for the vAMM.\n    /// * `amm_quote_asset_reserve` - Initial virtual quote asset reserves for the vAMM.\n    /// * `trade_fee_rate` - Fee rate for trades (e.g., 1000 for 0.1%).\n    /// * `liquidation_fee_rate` - Fee for liquidators.\n    /// * `initial_margin_ratio` - Initial margin ratio requirement.\n    /// * `maintenance_margin_ratio` - Maintenance margin ratio requirement.\n    pub fn create_market(\n        ctx: Context<CreateMarket>,\n        market_index: u16,\n        amm_base_asset_reserve: u128,\n        amm_quote_asset_reserve: u128,\n        trade_fee_rate: u64,\n        liquidation_fee_rate: u64,\n        initial_margin_ratio: u64,\n        maintenance_margin_ratio: u64,\n    ) -> Result<()> {\n        instructions::create_market::handle(\n            ctx,\n            market_index,\n            amm_base_asset_reserve,\n            amm_quote_asset_reserve,\n            trade_fee_rate,\n            liquidation_fee_rate,\n            initial_margin_ratio,\n            maintenance_margin_ratio,\n        )\n    }\n\n    /// Creates a user account PDA to store their positions and collateral.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    pub fn create_user(ctx: Context<CreateUser>) -> Result<()> {\n        instructions::user::handle_create_user(ctx)\n    }\n\n    /// Deposits collateral into the user's account.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `amount` - The amount of collateral to deposit.\n    pub fn deposit_collateral(ctx: Context<DepositCollateral>, amount: u64) -> Result<()> {\n        instructions::user::handle_deposit_collateral(ctx, amount)\n    }\n\n    /// Withdraws collateral from the user's account.\n    /// Fails if the withdrawal would push the user below the initial margin requirement.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `amount` - The amount of collateral to withdraw.\n    pub fn withdraw_collateral(ctx: Context<WithdrawCollateral>, amount: u64) -> Result<()> {\n        instructions::user::handle_withdraw_collateral(ctx, amount)\n    }\n\n    /// Opens a new long or short position or modifies an existing one.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `base_asset_amount` - The amount of the base asset to trade. Positive for long, negative for short.\n    /// * `limit_price` - The price limit for the trade. The trade will only execute if the resulting price is better.\n    pub fn open_position(\n        ctx: Context<OpenPosition>,\n        base_asset_amount: i128,\n        limit_price: u128,\n    ) -> Result<()> {\n        instructions::trade::handle_open_position(ctx, base_asset_amount, limit_price)\n    }\n\n    /// Closes an existing position.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `market_index` - The index of the market to close the position in.\n    pub fn close_position(ctx: Context<ClosePosition>, market_index: u16) -> Result<()> {\n        instructions::trade::handle_close_position(ctx, market_index)\n    }\n\n    /// Liquidates a user's position if their margin ratio is below the maintenance requirement.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `market_index` - The index of the market to liquidate the position in.\n    pub fn liquidate(ctx: Context<Liquidate>, market_index: u16) -> Result<()> {\n        instructions::liquidation::handle_liquidate(ctx, market_index)\n    }\n\n    /// Settles the funding rate payment for a user's position.\n    ///\n    /// # Arguments\n    ///\n    /// * `ctx` - The context for the instruction.\n    /// * `market_index` - The index of the market to settle funding for.\n    pub fn settle_funding(ctx: Context<SettleFunding>, market_index: u16) -> Result<()> {\n        instructions::funding::handle_settle_funding(ctx, market_index)\n    }\n}\n"
    },
    "error": {
      "filename": "programs/perp_dex/src/error.rs",
      "content": "use anchor_lang::prelude::*;\n\n#[error_code]\npub enum PerpError {\n    #[msg(\"Invalid calculation\")]\n    InvalidCalculation,\n    #[msg(\"Math overflow\")]\n    MathOverflow,\n    #[msg(\"Invalid Oracle Price\")]\n    InvalidOraclePrice,\n    #[msg(\"Oracle price is stale\")]\n    StaleOraclePrice,\n    #[msg(\"AMM price is outside the limit price\")]\n    PriceSlippage,\n    #[msg(\"Invalid trade direction\")]\n    InvalidTradeDirection,\n    #[msg(\"Market is paused\")]\n    MarketPaused,\n    #[msg(\"Position not found for the given market\")]\n    PositionNotFound,\n    #[msg(\"No position to close\")]\n    NoPositionToClose,\n    #[msg(\"Position is not liquidatable\")]\n    PositionNotLiquidatable,\n    #[msg(\"Insufficient collateral for withdrawal or trade\")]\n    InsufficientCollateral,\n    #[msg(\"Cannot withdraw funds, it would cause a margin call\")]\n    WithdrawalCausesMarginCall,\n    #[msg(\"Cannot open position, it would cause an immediate margin call\")]\n    PositionCausesMarginCall,\n    #[msg(\"Invalid amount for deposit or withdrawal\")]\n    InvalidAmount,\n    #[msg(\"The market index provided is invalid or out of bounds\")]\n    InvalidMarketIndex,\n    #[msg(\"Market is in an unhealthy state\")]\n    UnhealthyMarketState,\n    #[msg(\"Re-entrancy guard is active\")]\n    ReentrancyGuardActive,\n    #[msg(\"Funding was already settled for the period\")]\n    FundingAlreadySettled,\n}\n"
    },
    "state_constants": {
      "filename": "programs/perp_dex/src/state/constants.rs",
      "content": "//! Constants used throughout the program.\n\nuse anchor_lang::prelude::*;\n\n/// Seed for the main program state PDA.\npub const PROGRAM_SEED: &[u8] = b\"perp_dex_state\";\n\n/// Seed for the collateral vault PDA.\npub const VAULT_SEED: &[u8] = b\"collateral_vault\";\n\n/// Seed for the market PDA.\npub const MARKET_SEED: &[u8] = b\"market\";\n\n/// Seed for the user account PDA.\npub const USER_SEED: &[u8] = b\"user\";\n\n/// Precision for prices and assets (10^9).\npub const PRECISION: u128 = 1_000_000_000;\n\n/// Precision for collateral (USDC, 10^6).\npub const COLLATERAL_PRECISION: u64 = 1_000_000;\n\n/// Maximum number of positions a user can hold.\npub const MAX_POSITIONS: usize = 8;\n\n/// Oracle price validity duration in seconds (e.g., 60 seconds).\npub const ORACLE_STALENESS_THRESHOLD: i64 = 60;\n\n/// Funding rate period in seconds (e.g., 1 hour).\npub const FUNDING_PERIOD: i64 = 3600;\n"
    },
    "state_main": {
      "filename": "programs/perp_dex/src/state/state.rs",
      "content": "use anchor_lang::prelude::*;\n\n/// Global state for the perpetuals DEX.\n#[account]\n#[derive(Default)]\npub struct State {\n    /// The administrator of the program.\n    pub admin: Pubkey,\n    /// The mint for the collateral asset (e.g., USDC).\n    pub usdc_mint: Pubkey,\n    /// PDA bump for the state account.\n    pub bump: u8,\n    /// Number of markets created.\n    pub number_of_markets: u16,\n    /// Is the program paused (e.g., for upgrades).\n    pub paused: bool,\n}\n\nimpl State {\n    pub const LEN: usize = 8 + 32 + 32 + 1 + 2 + 1 + 200; // Padding\n}\n"
    },
    "state_market": {
      "filename": "programs/perp_dex/src/state/market.rs",
      "content": "use anchor_lang::prelude::*;\nuse bytemuck::{Pod, Zeroable};\nuse crate::state::constants::PRECISION;\n\n/// Represents a single perpetuals market.\n#[account(zero_copy)]\n#[repr(C)]\n#[derive(Default, Pod, Zeroable)]\npub struct Market {\n    /// Index of the market.\n    pub market_index: u16,\n    /// Is the market initialized.\n    pub initialized: bool,\n    /// Is the market paused for trading.\n    pub paused: bool,\n    pub bump: u8,\n\n    // vAMM state\n    pub amm_base_asset_reserve: u128,\n    pub amm_quote_asset_reserve: u128,\n    pub amm_k_constant: u128,\n\n    // Oracle\n    pub oracle_price_feed: Pubkey,\n\n    // Fees\n    /// Fee rate on trades (scaled by 1_000_000).\n    pub trade_fee_rate: u64,\n    /// Fee for liquidators (scaled by 1_000_000).\n    pub liquidation_fee_rate: u64,\n\n    // Margin requirements\n    /// Initial margin ratio (scaled by 1_000_000).\n    pub initial_margin_ratio: u64,\n    /// Maintenance margin ratio (scaled by 1_000_000).\n    pub maintenance_margin_ratio: u64,\n\n    // Funding rate\n    pub last_funding_rate: i128,\n    pub last_funding_ts: i64,\n    pub funding_period: i64,\n\n    // Open Interest\n    pub open_interest_base: u128, // Total open interest in base asset terms\n    \n    pub _padding: [u8; 256], // Padding for future upgrades\n}\n\nimpl Market {\n    pub fn get_mark_price(&self) -> Result<u128> {\n        if self.amm_base_asset_reserve == 0 {\n            return Ok(0);\n        }\n        self.amm_quote_asset_reserve\n            .checked_mul(PRECISION)\n            .and_then(|n| n.checked_div(self.amm_base_asset_reserve))\n            .ok_or(ErrorCode::InvalidCalculation.into())\n    }\n}\n"
    },
    "state_user": {
      "filename": "programs/perp_dex/src/state/user.rs",
      "content": "use anchor_lang::prelude::*;\nuse bytemuck::{Pod, Zeroable};\nuse crate::state::constants::{MAX_POSITIONS, PRECISION};\nuse crate::error::PerpError;\n\n/// A user's position in a single market.\n#[zero_copy]\n#[repr(C)]\n#[derive(Default, Pod, Zeroable)]\npub struct Position {\n    /// Market index this position belongs to.\n    pub market_index: u16,\n    /// The amount of base asset. Positive for long, negative for short.\n    pub base_asset_amount: i128,\n    /// The quote asset amount used to acquire the position.\n    pub quote_asset_amount: u128,\n    /// Last cumulative funding rate settled.\n    pub last_cumulative_funding_rate: i128,\n    pub last_settled_funding_ts: i64,\n}\n\nimpl Position {\n    /// Calculates the unrealized PnL for the position.\n    pub fn get_unrealized_pnl(&self, mark_price: u128) -> Result<i128> {\n        if self.base_asset_amount == 0 {\n            return Ok(0);\n        }\n\n        // Value of position at current mark price\n        let current_value = self.base_asset_amount.abs()\n            .checked_mul(mark_price)\n            .ok_or(PerpError::MathOverflow)?;\n\n        // Value of position at entry\n        let entry_value = self.quote_asset_amount\n            .checked_mul(PRECISION)\n            .ok_or(PerpError::MathOverflow)?;\n\n        let pnl = if self.base_asset_amount > 0 { // Long position\n            current_value.checked_sub(entry_value)\n        } else { // Short position\n            entry_value.checked_sub(current_value)\n        }.ok_or(PerpError::MathOverflow)?;\n\n        Ok(pnl as i128)\n    }\n}\n\n/// A user's account storing collateral and positions.\n#[account(zero_copy)]\n#[repr(C)]\npub struct User {\n    /// The authority (owner) of this account.\n    pub authority: Pubkey,\n    /// The PDA bump.\n    pub bump: u8,\n    /// Is the user account initialized.\n    pub initialized: bool,\n    /// Prevents re-entrant CPIs during sensitive operations.\n    pub operation_lock: bool,\n    \n    // Collateral\n    /// Total collateral deposited (in collateral precision).\n    pub collateral: u64,\n\n    // Positions\n    pub positions: [Position; MAX_POSITIONS],\n\n    pub _padding: [u8; 256], // Padding for future upgrades\n}\n\nimpl User {\n    pub fn find_position_mut(&mut self, market_index: u16) -> Result<&mut Position> {\n        self.positions\n            .iter_mut()\n            .find(|p| p.market_index == market_index && p.base_asset_amount != 0)\n            .ok_or(PerpError::PositionNotFound.into())\n    }\n    \n    pub fn find_or_create_position_mut(&mut self, market_index: u16) -> Result<&mut Position> {\n        // Find an existing position\n        if let Some(pos) = self.positions.iter_mut().find(|p| p.market_index == market_index) {\n            return Ok(pos);\n        }\n        // Or find an empty slot for a new one\n        if let Some(pos) = self.positions.iter_mut().find(|p| p.base_asset_amount == 0) {\n            pos.market_index = market_index;\n            return Ok(pos);\n        }\n        Err(PerpError::InvalidMarketIndex.into())\n    }\n}\n"
    },
    "instructions_mod": {
      "filename": "programs/perp_dex/src/instructions/mod.rs",
      "content": "pub mod create_market;\npub mod funding;\npub mod initialize;\npub mod liquidation;\npub mod trade;\npub mod user;\n\npub use create_market::*;\npub use funding::*;\npub use initialize::*;\npub use liquidation::*;\npub use trade::*;\npub use user::*;\n"
    },
    "instructions_initialize": {
      "filename": "programs/perp_dex/src/instructions/initialize.rs",
      "content": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{Mint, Token};\nuse crate::state::constants::{PROGRAM_SEED, VAULT_SEED};\nuse crate::state::state::State;\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub admin: Signer<'info>,\n\n    #[account(\n        init,\n        payer = admin,\n        space = State::LEN,\n        seeds = [PROGRAM_SEED],\n        bump\n    )]\n    pub program_state: Account<'info, State>,\n\n    /// The mint for the collateral asset (e.g., USDC).\n    pub usdc_mint: Account<'info, Mint>,\n\n    #[account(\n        init,\n        payer = admin,\n        seeds = [VAULT_SEED, usdc_mint.key().as_ref()],\n        bump,\n        token::mint = usdc_mint,\n        token::authority = program_state,\n    )]\n    pub collateral_vault: Account<'info, anchor_spl::token::TokenAccount>,\n\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\npub fn handle(ctx: Context<Initialize>, usdc_mint: Pubkey) -> Result<()> {\n    let state = &mut ctx.accounts.program_state;\n    state.admin = *ctx.accounts.admin.key;\n    state.usdc_mint = usdc_mint;\n    state.bump = ctx.bumps.program_state;\n    state.number_of_markets = 0;\n    state.paused = false;\n\n    Ok(())\n}\n"
    },
    "instructions_create_market": {
      "filename": "programs/perp_dex/src/instructions/create_market.rs",
      "content": "use anchor_lang::prelude::*;\nuse pyth_sdk_solana::PriceFeed;\nuse crate::state::constants::{FUNDING_PERIOD, MARKET_SEED};\nuse crate::state::market::Market;\nuse crate::state::state::State;\nuse crate::error::PerpError;\n\n#[derive(Accounts)]\n#[instruction(market_index: u16)]\npub struct CreateMarket<'info> {\n    #[account(mut)]\n    pub admin: Signer<'info>,\n\n    #[account(\n        mut,\n        has_one = admin,\n    )]\n    pub program_state: Account<'info, State>,\n\n    #[account(\n        init,\n        payer = admin,\n        space = 8 + std::mem::size_of::<Market>(),\n        seeds = [MARKET_SEED, &market_index.to_le_bytes()],\n        bump\n    )]\n    pub market: AccountLoader<'info, Market>,\n\n    /// Pyth price feed for the market's underlying asset.\n    /// CHECK: This is a read-only account. We deserialize and check inside the instruction.\n    pub oracle_price_feed: AccountInfo<'info>,\n\n    pub system_program: Program<'info, System>,\n}\n\npub fn handle(\n    ctx: Context<CreateMarket>,\n    market_index: u16,\n    amm_base_asset_reserve: u128,\n    amm_quote_asset_reserve: u128,\n    trade_fee_rate: u64,\n    liquidation_fee_rate: u64,\n    initial_margin_ratio: u64,\n    maintenance_margin_ratio: u64,\n) -> Result<()> {\n    // Basic sanity checks\n    require_gt!(amm_base_asset_reserve, 0, PerpError::InvalidCalculation);\n    require_gt!(amm_quote_asset_reserve, 0, PerpError::InvalidCalculation);\n    require_gt!(initial_margin_ratio, maintenance_margin_ratio, PerpError::InvalidCalculation);\n\n    // Check and deserialize the Pyth price feed\n    let price_feed_info = &ctx.accounts.oracle_price_feed;\n    let price_feed: PriceFeed = pyth_sdk_solana::load_price_feed_from_account_info(price_feed_info)\n        .map_err(|_| error!(PerpError::InvalidOraclePrice))?;\n    let _current_price = price_feed.get_price().ok_or(PerpError::InvalidOraclePrice)?;\n\n    let mut market = ctx.accounts.market.load_init()?;\n    \n    market.market_index = market_index;\n    market.initialized = true;\n    market.paused = false;\n    market.bump = ctx.bumps.market;\n\n    market.amm_base_asset_reserve = amm_base_asset_reserve;\n    market.amm_quote_asset_reserve = amm_quote_asset_reserve;\n    market.amm_k_constant = amm_base_asset_reserve.checked_mul(amm_quote_asset_reserve).ok_or(PerpError::MathOverflow)?;\n    \n    market.oracle_price_feed = *price_feed_info.key;\n    \n    market.trade_fee_rate = trade_fee_rate;\n    market.liquidation_fee_rate = liquidation_fee_rate;\n    market.initial_margin_ratio = initial_margin_ratio;\n    market.maintenance_margin_ratio = maintenance_margin_ratio;\n\n    market.last_funding_ts = Clock::get()?.unix_timestamp;\n    market.funding_period = FUNDING_PERIOD;\n\n    ctx.accounts.program_state.number_of_markets = ctx.accounts.program_state.number_of_markets.checked_add(1).ok_or(PerpError::MathOverflow)?;\n\n    Ok(())\n}\n"
    },
    "instructions_user": {
      "filename": "programs/perp_dex/src/instructions/user.rs",
      "content": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};\nuse crate::state::constants::{USER_SEED, VAULT_SEED, COLLATERAL_PRECISION};\nuse crate::state::state::State;\nuse crate::state::user::User;\nuse crate::error::PerpError;\nuse crate::math::margin::meets_initial_margin_requirement;\nuse crate::validation::validate_user_not_locked;\n\n#[derive(Accounts)]\npub struct CreateUser<'info> {\n    #[account(mut)]\n    pub authority: Signer<'info>,\n\n    #[account(\n        init,\n        payer = authority,\n        space = 8 + std::mem::size_of::<User>(),\n        seeds = [USER_SEED, authority.key().as_ref()],\n        bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    pub system_program: Program<'info, System>,\n}\n\npub fn handle_create_user(ctx: Context<CreateUser>) -> Result<()> {\n    let mut user = ctx.accounts.user_account.load_init()?;\n    user.authority = *ctx.accounts.authority.key;\n    user.bump = ctx.bumps.user_account;\n    user.initialized = true;\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct DepositCollateral<'info> {\n    #[account(mut)]\n    pub authority: Signer<'info>,\n\n    #[account(\n        mut,\n        has_one = authority,\n        seeds = [USER_SEED, authority.key().as_ref()],\n        bump = user_account.load()?.bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    #[account(\n        mut,\n        seeds = [VAULT_SEED, usdc_mint.key().as_ref()],\n        bump,\n    )]\n    pub collateral_vault: Account<'info, TokenAccount>,\n\n    #[account(mut)]\n    pub user_collateral_account: Account<'info, TokenAccount>,\n    \n    pub usdc_mint: Account<'info, Mint>,\n    pub token_program: Program<'info, Token>,\n}\n\npub fn handle_deposit_collateral(ctx: Context<DepositCollateral>, amount: u64) -> Result<()> {\n    require_gt!(amount, 0, PerpError::InvalidAmount);\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    validate_user_not_locked(&user)?;\n\n    let cpi_accounts = Transfer {\n        from: ctx.accounts.user_collateral_account.to_account_info(),\n        to: ctx.accounts.collateral_vault.to_account_info(),\n        authority: ctx.accounts.authority.to_account_info(),\n    };\n    let cpi_program = ctx.accounts.token_program.to_account_info();\n    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n    token::transfer(cpi_ctx, amount)?;\n\n    user.collateral = user.collateral.checked_add(amount).ok_or(PerpError::MathOverflow)?;\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct WithdrawCollateral<'info> {\n    pub authority: Signer<'info>,\n\n    #[account(\n        mut,\n        has_one = authority,\n        seeds = [USER_SEED, authority.key().as_ref()],\n        bump = user_account.load()?.bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    #[account()] // Not mutable because it's the authority\n    pub program_state: Account<'info, State>,\n\n    #[account(\n        mut,\n        seeds = [VAULT_SEED, program_state.usdc_mint.key().as_ref()],\n        bump,\n    )]\n    pub collateral_vault: Account<'info, TokenAccount>,\n\n    #[account(mut)]\n    pub user_collateral_account: Account<'info, TokenAccount>,\n\n    pub token_program: Program<'info, Token>,\n}\n\npub fn handle_withdraw_collateral(ctx: Context<WithdrawCollateral>, amount: u64) -> Result<()> {\n    require_gt!(amount, 0, PerpError::InvalidAmount);\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    validate_user_not_locked(&user)?;\n\n    let free_collateral = user.collateral.checked_sub(amount).ok_or(PerpError::InsufficientCollateral)?;\n    user.collateral = free_collateral;\n\n    // This check is a simplification. A real implementation would need to iterate through\n    // all positions, calculate their margin requirements, and ensure the withdrawal\n    // doesn't violate the total position's initial margin requirement.\n    // For this example, we'll use a placeholder check.\n    require!(\n        meets_initial_margin_requirement(&user, &ctx.remaining_accounts)?, \n        PerpError::WithdrawalCausesMarginCall\n    );\n    \n    let state_bump = ctx.accounts.program_state.bump;\n    let seeds = &[&crate::state::constants::PROGRAM_SEED[..], &[state_bump]];\n    let signer = &[&seeds[..]];\n\n    let cpi_accounts = Transfer {\n        from: ctx.accounts.collateral_vault.to_account_info(),\n        to: ctx.accounts.user_collateral_account.to_account_info(),\n        authority: ctx.accounts.program_state.to_account_info(),\n    };\n    let cpi_program = ctx.accounts.token_program.to_account_info();\n    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n    token::transfer(cpi_ctx, amount)?;\n\n    // Reload to apply changes before drop\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    user.collateral = free_collateral;\n\n    Ok(())\n}\n"
    },
    "instructions_trade": {
      "filename": "programs/perp_dex/src/instructions/trade.rs",
      "content": "use anchor_lang::prelude::*;\nuse crate::state::market::Market;\nuse crate::state::user::User;\nuse crate::state::constants::{MARKET_SEED, USER_SEED, PRECISION};\nuse crate::error::PerpError;\nuse crate::math::amm;\nuse crate::math::margin::meets_initial_margin_requirement;\nuse crate::validation::{validate_user_not_locked, validate_market_not_paused};\n\n#[derive(Accounts)]\npub struct OpenPosition<'info> {\n    pub authority: Signer<'info>,\n\n    #[account(\n        mut,\n        has_one = authority,\n        seeds = [USER_SEED, authority.key().as_ref()],\n        bump = user_account.load()?.bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    #[account(\n        mut,\n        seeds = [MARKET_SEED, &market.load()?.market_index.to_le_bytes()],\n        bump = market.load()?.bump\n    )]\n    pub market: AccountLoader<'info, Market>,\n}\n\npub fn handle_open_position(ctx: Context<OpenPosition>, base_asset_amount: i128, limit_price: u128) -> Result<()> {\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    let mut market = ctx.accounts.market.load_mut()?;\n    validate_user_not_locked(&user)?;\n    validate_market_not_paused(&market)?;\n\n    let direction = if base_asset_amount > 0 { amm::TradeDirection::Long } else { amm::TradeDirection::Short };\n    let (new_quote_asset_reserve, new_base_asset_reserve) = amm::calculate_swap_output(\n        base_asset_amount.abs(), \n        market.amm_base_asset_reserve, \n        market.amm_quote_asset_reserve, \n        direction\n    )?;\n\n    let quote_asset_amount_acquired = market.amm_quote_asset_reserve.abs_diff(new_quote_asset_reserve);\n    let entry_price = quote_asset_amount_acquired.checked_mul(PRECISION)\n        .and_then(|n| n.checked_div(base_asset_amount.abs() as u128))\n        .ok_or(PerpError::MathOverflow)?;\n\n    // Slippage check\n    match direction {\n        amm::TradeDirection::Long => require_gte!(limit_price, entry_price, PerpError::PriceSlippage),\n        amm::TradeDirection::Short => require_lte!(limit_price, entry_price, PerpError::PriceSlippage),\n    }\n\n    market.amm_base_asset_reserve = new_base_asset_reserve;\n    market.amm_quote_asset_reserve = new_quote_asset_reserve;\n    \n    // Update User Position\n    let position = user.find_or_create_position_mut(market.market_index)?;\n    position.base_asset_amount = position.base_asset_amount.checked_add(base_asset_amount).ok_or(PerpError::MathOverflow)?;\n    position.quote_asset_amount = position.quote_asset_amount.checked_add(quote_asset_amount_acquired).ok_or(PerpError::MathOverflow)?;\n\n    // Margin Check (Simplified: Should check against total position value)\n    require!(meets_initial_margin_requirement(&user, &ctx.remaining_accounts)?, PerpError::PositionCausesMarginCall);\n\n    Ok(())\n}\n\n\n#[derive(Accounts)]\n#[instruction(market_index: u16)]\npub struct ClosePosition<'info> {\n    pub authority: Signer<'info>,\n\n    #[account(\n        mut,\n        has_one = authority,\n        seeds = [USER_SEED, authority.key().as_ref()],\n        bump = user_account.load()?.bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    #[account(\n        mut,\n        seeds = [MARKET_SEED, &market_index.to_le_bytes()],\n        bump = market.load()?.bump\n    )]\n    pub market: AccountLoader<'info, Market>,\n}\n\npub fn handle_close_position(ctx: Context<ClosePosition>, market_index: u16) -> Result<()> {\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    let mut market = ctx.accounts.market.load_mut()?;\n    validate_user_not_locked(&user)?;\n    validate_market_not_paused(&market)?;\n\n    let position_to_close = user.find_position_mut(market_index)?.clone(); // clone to avoid borrow checker issues\n    if position_to_close.base_asset_amount == 0 {\n        return err!(PerpError::NoPositionToClose);\n    }\n\n    let base_asset_amount_to_close = -position_to_close.base_asset_amount;\n    let direction = if base_asset_amount_to_close > 0 { amm::TradeDirection::Long } else { amm::TradeDirection::Short };\n    \n    let (new_quote_asset_reserve, new_base_asset_reserve) = amm::calculate_swap_output(\n        base_asset_amount_to_close.abs(),\n        market.amm_base_asset_reserve,\n        market.amm_quote_asset_reserve,\n        direction\n    )?;\n\n    let quote_asset_returned = market.amm_quote_asset_reserve.abs_diff(new_quote_asset_reserve);\n\n    // PnL calculation\n    let pnl = if position_to_close.base_asset_amount > 0 { // Closing a long\n        (quote_asset_returned as i128) - (position_to_close.quote_asset_amount as i128)\n    } else { // Closing a short\n        (position_to_close.quote_asset_amount as i128) - (quote_asset_returned as i128)\n    };\n\n    // Settle PnL to user's collateral\n    // This is a simplification. Should handle fees and precision conversions.\n    if pnl > 0 {\n        user.collateral = user.collateral.checked_add((pnl / (PRECISION as i128)) as u64).ok_or(PerpError::MathOverflow)?;\n    } else {\n        user.collateral = user.collateral.checked_sub((pnl.abs() / (PRECISION as i128)) as u64).ok_or(PerpError::MathOverflow)?;\n    }\n\n    market.amm_base_asset_reserve = new_base_asset_reserve;\n    market.amm_quote_asset_reserve = new_quote_asset_reserve;\n\n    // Reset user position\n    let position = user.find_position_mut(market_index)?;\n    *position = Default::default();\n    position.market_index = market_index; // Keep market index for future use\n\n    Ok(())\n}\n"
    },
    "instructions_liquidation": {
      "filename": "programs/perp_dex/src/instructions/liquidation.rs",
      "content": "use anchor_lang::prelude::*;\nuse crate::state::constants::{MARKET_SEED, USER_SEED};\nuse crate::state::market::Market;\nuse crate::state::user::User;\nuse crate::error::PerpError;\nuse crate::math::margin::is_liquidatable;\nuse crate::validation::{validate_user_not_locked, validate_market_not_paused};\n\n#[derive(Accounts)]\n#[instruction(market_index: u16)]\npub struct Liquidate<'info> {\n    pub liquidator: Signer<'info>,\n\n    /// The user account being liquidated.\n    #[account(\n        mut,\n        seeds = [USER_SEED, user_account.load()?.authority.as_ref()],\n        bump = user_account.load()?.bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    #[account(\n        mut,\n        seeds = [MARKET_SEED, &market_index.to_le_bytes()],\n        bump = market.load()?.bump\n    )]\n    pub market: AccountLoader<'info, Market>,\n}\n\npub fn handle_liquidate(ctx: Context<Liquidate>, market_index: u16) -> Result<()> {\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    let market = ctx.accounts.market.load()?;\n    validate_user_not_locked(&user)?;\n    validate_market_not_paused(&market)?;\n\n    user.operation_lock = true; // Lock user account during liquidation\n\n    // This check is a simplification. A real implementation needs the oracle price.\n    // Here we pass `remaining_accounts` which should contain the oracle.\n    require!(is_liquidatable(&user, &market, &ctx.remaining_accounts)?, PerpError::PositionNotLiquidatable);\n\n    let position_to_liquidate = user.find_position_mut(market_index)?.clone();\n\n    // Simplified liquidation: close the position and transfer a fee to the liquidator.\n    // A full implementation would involve an insurance fund and more complex logic.\n\n    // Simulate closing the position (code from `close_position` would be reused here)\n    // ... complex logic to close position against AMM or an auction ...\n\n    // Calculate liquidation fee\n    let position_value = position_to_liquidate.base_asset_amount.abs()\n        .checked_mul(market.get_mark_price()?)\n        .ok_or(PerpError::MathOverflow)?;\n    \n    let liquidation_fee = (position_value as u64)\n        .checked_mul(market.liquidation_fee_rate)\n        .and_then(|f| f.checked_div(1_000_000))\n        .ok_or(PerpError::MathOverflow)?;\n\n    // Settle fee from user's collateral\n    user.collateral = user.collateral.checked_sub(liquidation_fee).ok_or(PerpError::InsufficientCollateral)?;\n\n    // In a real implementation, the fee would be transferred to the liquidator's collateral account.\n    // For simplicity, we just deduct it here.\n\n    // Reset position\n    let position = user.find_position_mut(market_index)?;\n    *position = Default::default();\n    position.market_index = market_index;\n\n    user.operation_lock = false; // Unlock user account\n\n    Ok(())\n}\n"
    },
    "instructions_funding": {
      "filename": "programs/perp_dex/src/instructions/funding.rs",
      "content": "use anchor_lang::prelude::*;\nuse crate::state::constants::{MARKET_SEED, USER_SEED, PRECISION};\nuse crate::state::market::Market;\nuse crate::state::user::User;\nuse crate::error::PerpError;\nuse crate::validation::{validate_user_not_locked, validate_oracle_price};\n\n#[derive(Accounts)]\n#[instruction(market_index: u16)]\npub struct SettleFunding<'info> {\n    pub authority: Signer<'info>,\n\n    #[account(\n        mut,\n        has_one = authority,\n        seeds = [USER_SEED, authority.key().as_ref()],\n        bump = user_account.load()?.bump\n    )]\n    pub user_account: AccountLoader<'info, User>,\n\n    #[account(\n        mut,\n        seeds = [MARKET_SEED, &market_index.to_le_bytes()],\n        bump = market.load()?.bump\n    )]\n    pub market: AccountLoader<'info, Market>,\n    \n    /// CHECK: Oracle account, validated in handler\n    pub oracle_price_feed: AccountInfo<'info>,\n}\n\npub fn handle_settle_funding(ctx: Context<SettleFunding>, market_index: u16) -> Result<()> {\n    let mut user = ctx.accounts.user_account.load_mut()?;\n    let mut market = ctx.accounts.market.load_mut()?;\n    validate_user_not_locked(&user)?;\n\n    let position = user.find_position_mut(market_index)?;\n    require_keys_eq!(market.oracle_price_feed, ctx.accounts.oracle_price_feed.key());\n\n    let clock = Clock::get()?;\n    let now = clock.unix_timestamp;\n\n    // Check if enough time has passed since the last settlement for this user\n    let time_since_last_settle = now.checked_sub(position.last_settled_funding_ts).ok_or(PerpError::MathOverflow)?;\n    if time_since_last_settle < market.funding_period {\n        // Not an error, just nothing to do\n        return Ok(());\n    }\n\n    // Update market-wide funding rate if needed\n    let time_since_last_update = now.checked_sub(market.last_funding_ts).ok_or(PerpError::MathOverflow)?;\n    if time_since_last_update >= market.funding_period {\n        let oracle_price = validate_oracle_price(&ctx.accounts.oracle_price_feed, &clock)?;\n        let mark_price = market.get_mark_price()?;\n        \n        let premium = (mark_price as i128).checked_sub(oracle_price as i128).ok_or(PerpError::MathOverflow)?;\n        let funding_rate = premium.checked_mul(PRECISION as i128)\n            .and_then(|p| p.checked_div(24))\n            .ok_or(PerpError::MathOverflow)?; // Simplified: premium / 24 for hourly funding over 24h\n\n        market.last_funding_rate = funding_rate;\n        market.last_funding_ts = now;\n    }\n\n    // Calculate funding payment for the user\n    let funding_payment = position.base_asset_amount\n        .checked_mul(market.last_funding_rate)\n        .and_then(|p| p.checked_div(PRECISION as i128))\n        .ok_or(PerpError::MathOverflow)?;\n    \n    // Settle payment (longs pay shorts if rate is positive)\n    let collateral_change = -funding_payment;\n\n    if collateral_change > 0 {\n        user.collateral = user.collateral.checked_add(collateral_change as u64).ok_or(PerpError::MathOverflow)?;\n    } else {\n        user.collateral = user.collateral.checked_sub(collateral_change.abs() as u64).ok_or(PerpError::MathOverflow)?;\n    }\n\n    position.last_settled_funding_ts = now;\n\n    Ok(())\n}\n"
    },
    "math_mod": {
      "filename": "programs/perp_dex/src/math/mod.rs",
      "content": "pub mod amm;\npub mod margin;\n"
    },
    "math_amm": {
      "filename": "programs/perp_dex/src/math/amm.rs",
      "content": "use anchor_lang::prelude::*;\nuse crate::error::PerpError;\n\n#[derive(PartialEq, Eq, Clone, Copy)]\npub enum TradeDirection {\n    Long,\n    Short,\n}\n\n/// Calculates the output of a swap against the vAMM.\n/// Returns (new_quote_asset_reserve, new_base_asset_reserve).\npub fn calculate_swap_output(\n    base_asset_amount: u128,\n    base_asset_reserve: u128,\n    quote_asset_reserve: u128,\n    direction: TradeDirection,\n) -> Result<(u128, u128)> {\n    if base_asset_reserve == 0 || quote_asset_reserve == 0 {\n        return Err(PerpError::UnhealthyMarketState.into());\n    }\n\n    let k = base_asset_reserve.checked_mul(quote_asset_reserve).ok_or(PerpError::MathOverflow)?;\n\n    let new_base_asset_reserve = match direction {\n        TradeDirection::Long => base_asset_reserve.checked_sub(base_asset_amount),\n        TradeDirection::Short => base_asset_reserve.checked_add(base_asset_amount),\n    }.ok_or(PerpError::MathOverflow)?;\n\n    let new_quote_asset_reserve = k.checked_div(new_base_asset_reserve).ok_or(PerpError::MathOverflow)?;\n\n    Ok((new_quote_asset_reserve, new_base_asset_reserve))\n}\n"
    },
    "math_margin": {
      "filename": "programs/perp_dex/src/math/margin.rs",
      "content": "use anchor_lang::prelude::*;\nuse crate::state::user::{User, Position};\nuse crate::state::market::Market;\nuse crate::state::constants::{PRECISION, COLLATERAL_PRECISION};\nuse crate::validation::validate_oracle_price;\nuse crate::error::PerpError;\n\n/// Simplified margin check. A production system would iterate all positions.\n/// This version assumes a single position for clarity.\npub fn meets_initial_margin_requirement(\n    user: &User,\n    remaining_accounts: &[AccountInfo],\n) -> Result<bool> {\n    // In a real system, you'd need to find all markets and oracles for the user's positions.\n    // Here, we assume the relevant market and oracle are passed in `remaining_accounts`.\n    let market_info = remaining_accounts.get(0).ok_or(PerpError::InvalidMarketIndex)?;\n    let oracle_info = remaining_accounts.get(1).ok_or(PerpError::InvalidOraclePrice)?;\n    \n    let market: AccountLoader<Market> = AccountLoader::try_from(market_info)?;\n    let market = market.load()?;\n    let oracle_price = validate_oracle_price(oracle_info, &Clock::get()?)?;\n\n    let total_position_value = get_total_position_value(user, &market, oracle_price)?;\n    let total_collateral_value = user.collateral as u128 * (PRECISION / COLLATERAL_PRECISION as u128);\n\n    if total_position_value == 0 {\n        return Ok(true);\n    }\n\n    let margin_ratio = total_collateral_value.checked_mul(PRECISION)\n        .and_then(|n| n.checked_div(total_position_value))\n        .ok_or(PerpError::MathOverflow)?;\n\n    Ok(margin_ratio >= market.initial_margin_ratio as u128)\n}\n\npub fn is_liquidatable(\n    user: &User,\n    market: &Market,\n    remaining_accounts: &[AccountInfo],\n) -> Result<bool> {\n    let oracle_info = remaining_accounts.get(0).ok_or(PerpError::InvalidOraclePrice)?;\n    let oracle_price = validate_oracle_price(oracle_info, &Clock::get()?)?;\n\n    let total_position_value = get_total_position_value(user, market, oracle_price)?;\n    let total_collateral_value = user.collateral as u128 * (PRECISION / COLLATERAL_PRECISION as u128);\n\n    if total_position_value == 0 {\n        return Ok(false);\n    }\n\n    let margin_ratio = total_collateral_value.checked_mul(PRECISION)\n        .and_then(|n| n.checked_div(total_position_value))\n        .ok_or(PerpError::MathOverflow)?;\n\n    Ok(margin_ratio < market.maintenance_margin_ratio as u128)\n}\n\nfn get_total_position_value(user: &User, market: &Market, price: u128) -> Result<u128> {\n    let mut total_value = 0u128;\n    for position in user.positions.iter() {\n        if position.market_index == market.market_index && position.base_asset_amount != 0 {\n            let value = (position.base_asset_amount.abs() as u128).checked_mul(price)\n                .and_then(|n| n.checked_div(PRECISION))\n                .ok_or(PerpError::MathOverflow)?;\n            total_value = total_value.checked_add(value).ok_or(PerpError::MathOverflow)?;\n        }\n    }\n    Ok(total_value)\n}\n"
    },
    "validation_mod": {
      "filename": "programs/perp_dex/src/validation.rs",
      "content": "use anchor_lang::prelude::*;\nuse pyth_sdk_solana::{load_price_feed_from_account_info, PriceFeed};\nuse crate::state::constants::{ORACLE_STALENESS_THRESHOLD, PRECISION};\nuse crate::state::market::Market;\nuse crate::state::user::User;\nuse crate::error::PerpError;\n\n/// Validates the oracle price feed is not stale.\npub fn validate_oracle_price(oracle_info: &AccountInfo, clock: &Clock) -> Result<u128> {\n    let price_feed: PriceFeed = load_price_feed_from_account_info(oracle_info)\n        .map_err(|_| error!(PerpError::InvalidOraclePrice))?;\n\n    let price = price_feed.get_price_no_older_than(clock.unix_timestamp, ORACLE_STALENESS_THRESHOLD)\n        .ok_or(PerpError::StaleOraclePrice)?;\n\n    // Convert Pyth price (i64 with an exponent) to our u128 format with PRECISION.\n    if price.expo > 0 {\n        return Err(PerpError::InvalidOraclePrice.into()); // We expect negative exponent for prices < 1\n    }\n\n    let scale_factor = 10u128.pow(price.expo.abs() as u32);\n    let oracle_price_u128 = (price.price as u128).checked_mul(PRECISION)\n        .and_then(|p| p.checked_div(scale_factor))\n        .ok_or(PerpError::MathOverflow)?;\n    \n    Ok(oracle_price_u128)\n}\n\n/// Checks if the user account is locked for a sensitive operation.\npub fn validate_user_not_locked(user: &User) -> Result<()> {\n    require!(!user.operation_lock, PerpError::ReentrancyGuardActive);\n    Ok(())\n}\n\n/// Checks if the market is paused.\npub fn validate_market_not_paused(market: &Market) -> Result<()> {\n    require!(!market.paused, PerpError::MarketPaused);\n    Ok(())\n}\n"
    }
  },
  "tests": {
    "perp_dex_ts": {
      "filename": "tests/perp_dex.ts",
      "content": "import * as anchor from '@coral-xyz/anchor';\nimport { Program } from '@coral-xyz/anchor';\nimport { PerpDex } from '../target/types/perp_dex';\nimport { Keypair, PublicKey, SystemProgram } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID, createMint, createAccount, mintTo } from '@solana/spl-token';\nimport { assert } from 'chai';\n\n// A mock Pyth price feed account for testing\n// In a real test suite, this would be managed by a more robust framework like Switchboard's test utils\nconst MOCK_PYTH_PRICE_FEED = new Keypair();\n\nasync function createPythAccount(provider: anchor.AnchorProvider, price: number, expo: number) {\n  const pythData = Buffer.alloc(3312); // Size of PriceFeed account\n  // A simplified mock of Pyth data. Real tests need a more accurate representation.\n  pythData.writeInt32LE(0x50595448, 0); // Magic number\n  pythData.writeInt32LE(2, 4); // Version\n  pythData.writeInt32LE(1, 8); // Type (Price)\n  // ... other fields\n  pythData.writeBigInt64LE(BigInt(price), 224); // price\n  pythData.writeInt32LE(expo, 232); // exponent\n  pythData.writeBigInt64LE(BigInt(Date.now() / 1000), 248); // publish time\n\n  await provider.connection.confirmTransaction(\n    await provider.connection.sendTransaction(\n      new anchor.web3.Transaction().add(\n        SystemProgram.createAccount({\n          fromPubkey: provider.wallet.publicKey,\n          newAccountPubkey: MOCK_PYTH_PRICE_FEED.publicKey,\n          space: pythData.length,\n          lamports: await provider.connection.getMinimumBalanceForRentExemption(pythData.length),\n          programId: new PublicKey('gSbePebfvPy74C2pcN1gAmG3GzgPKaeNVsV4UvEzPqr'), // Mock Pyth program ID\n        })\n      ),\n      [MOCK_PYTH_PRICE_FEED]\n    )\n  );\n\n  const account = await provider.connection.getAccountInfo(MOCK_PYTH_PRICE_FEED.publicKey);\n  account.data = pythData;\n  // This is a workaround for local tests. In a live testnet, you'd just use a real Pyth feed.\n}\n\ndescribe('perp_dex', () => {\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  const program = anchor.workspace.PerpDex as Program<PerpDex>;\n  const admin = provider.wallet as anchor.Wallet;\n\n  let usdcMint: PublicKey;\n  let userCollateralAccount: PublicKey;\n  let collateralVault: PublicKey;\n  let programState: PublicKey;\n  let userAccount: PublicKey;\n\n  before(async () => {\n    // Create USDC mint\n    usdcMint = await createMint(provider.connection, admin.payer, admin.publicKey, null, 6);\n\n    // Create a user token account for USDC\n    userCollateralAccount = await createAccount(provider.connection, admin.payer, usdcMint, admin.publicKey);\n\n    // Mint some USDC to the user\n    await mintTo(provider.connection, admin.payer, usdcMint, userCollateralAccount, admin.payer, 1000 * 10 ** 6);\n    \n    // Setup Pyth mock account\n    await createPythAccount(provider, 100 * 10 ** 8, -8); // Mock SOL price at $100\n  });\n\n  it('Is initialized!', async () => {\n    [programState] = PublicKey.findProgramAddressSync(\n      [Buffer.from('perp_dex_state')],\n      program.programId\n    );\n\n    [collateralVault] = PublicKey.findProgramAddressSync(\n      [Buffer.from('collateral_vault'), usdcMint.toBuffer()],\n      program.programId\n    );\n\n    await program.methods\n      .initialize(usdcMint)\n      .accounts({\n        admin: admin.publicKey,\n        programState: programState,\n        usdcMint: usdcMint,\n        collateralVault: collateralVault,\n        systemProgram: SystemProgram.programId,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      })\n      .rpc();\n\n    const state = await program.account.state.fetch(programState);\n    assert.ok(state.admin.equals(admin.publicKey));\n    assert.ok(state.usdcMint.equals(usdcMint));\n  });\n\n  it('Creates a market', async () => {\n    const marketIndex = 0;\n    const [marketKey] = PublicKey.findProgramAddressSync(\n      [Buffer.from('market'), new anchor.BN(marketIndex).toArrayLike(Buffer, 'le', 2)],\n      program.programId\n    );\n\n    await program.methods\n      .createMarket(\n        marketIndex,\n        new anchor.BN('100000000000'), // 100 base\n        new anchor.BN('10000000000000'), // 10000 quote (implies price of 100)\n        new anchor.BN(1000), // 0.1% trade fee\n        new anchor.BN(50000), // 5% liquidation fee\n        new anchor.BN(100000), // 10% initial margin\n        new anchor.BN(50000) // 5% maintenance margin\n      )\n      .accounts({\n        admin: admin.publicKey,\n        programState: programState,\n        market: marketKey,\n        oraclePriceFeed: MOCK_PYTH_PRICE_FEED.publicKey,\n        systemProgram: SystemProgram.programId,\n      })\n      .rpc();\n\n    const market = await program.account.market.fetch(marketKey);\n    assert.equal(market.marketIndex, marketIndex);\n    assert.isTrue(market.initialized);\n  });\n\n  it('Creates a user account and deposits collateral', async () => {\n    [userAccount] = PublicKey.findProgramAddressSync(\n      [Buffer.from('user'), admin.publicKey.toBuffer()],\n      program.programId\n    );\n\n    await program.methods\n      .createUser()\n      .accounts({\n        authority: admin.publicKey,\n        userAccount: userAccount,\n        systemProgram: SystemProgram.programId,\n      })\n      .rpc();\n\n    const depositAmount = new anchor.BN(100 * 10 ** 6); // 100 USDC\n    await program.methods\n      .depositCollateral(depositAmount)\n      .accounts({\n        authority: admin.publicKey,\n        userAccount: userAccount,\n        collateralVault: collateralVault,\n        userCollateralAccount: userCollateralAccount,\n        usdcMint: usdcMint,\n        tokenProgram: TOKEN_PROGRAM_ID,\n      })\n      .rpc();\n\n    const user = await program.account.user.fetch(userAccount);\n    assert.equal(user.collateral.toString(), depositAmount.toString());\n  });\n\n  it('Opens a long position', async () => {\n    const marketIndex = 0;\n    const [marketKey] = PublicKey.findProgramAddressSync(\n      [Buffer.from('market'), new anchor.BN(marketIndex).toArrayLike(Buffer, 'le', 2)],\n      program.programId\n    );\n\n    // Open a 1 SOL long position (1 * 10^9 base units)\n    const baseAssetAmount = new anchor.BN('1000000000');\n    // Limit price slightly above expected to ensure it fills\n    const limitPrice = new anchor.BN('101000000000'); // $101\n\n    await program.methods\n      .openPosition(baseAssetAmount, limitPrice)\n      .accounts({\n        authority: admin.publicKey,\n        userAccount: userAccount,\n        market: marketKey,\n      })\n      // Pass remaining accounts for margin checks\n      .remainingAccounts([\n          { pubkey: marketKey, isSigner: false, isWritable: false },\n          { pubkey: MOCK_PYTH_PRICE_FEED.publicKey, isSigner: false, isWritable: false },\n      ])\n      .rpc();\n\n    const user = await program.account.user.fetch(userAccount);\n    const position = user.positions[0];\n    assert.equal(position.marketIndex, marketIndex);\n    assert.equal(position.baseAssetAmount.toString(), baseAssetAmount.toString());\n    assert.isTrue(position.quoteAssetAmount.gtn(0)); // check that quote was exchanged\n  });\n});\n"
    }
  },
  "deployment": {
    "guide": "### 1. Setup Environment\n\n- Install Rust: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`\n- Install Solana Tool Suite: `sh -c \"$(curl -sSfL https://release.solana.com/v1.18.1/install)\"`\n- Install Anchor: `cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked --force`\n- Install Node.js and Yarn.\n\n### 2. Build the Program\n\nNavigate to the root directory of the project and run:\n```sh\nanchor build\n```\nThis will compile the Rust code into a BPF binary and generate the IDL (Interface Definition Language) in `target/idl/perp_dex.json` and TypeScript types in `target/types/perp_dex.ts`.\n\n### 3. Configure Solana CLI\n\nSet your Solana cluster configuration. For local testing:\n```sh\nsolana config set --url localhost\nsolana-test-validator\n```\nIn another terminal, set your keypair:\n```sh\nsolana config set --keypair ~/.config/solana/id.json\nsolana airdrop 100\n```\n\n### 4. Deploy the Program\n\nRun the deploy command:\n```sh\nanchor deploy\n```\nAfter deployment, Anchor will write the new program ID to `declare_id!` in `src/lib.rs` and to `programs/perp_dex/Cargo.toml`. Make sure to copy the final program ID into the `declare_id!` macro.\n\n### 5. Run Tests\n\nExecute the integration tests to verify the program's functionality against your local validator.\n```sh\nanchor test\n```\nThis will build, deploy, and run the tests defined in `tests/perp_dex.ts`.\n\n### Upgrading the Program\n\nTo upgrade a deployed program, first rebuild the new version with `anchor build`. Then, run the deploy command again with the same buffer and program keypair. Anchor handles this automatically.\n\n```sh\nanchor deploy\n```\n\n**Important:** Since this program uses `zero_copy`, adding new fields to account structs requires careful planning. New fields should be added to the `_padding` section at the end of the struct to maintain data layout compatibility. Changing existing field order or size is a breaking change and will require a full program migration."
  }
}