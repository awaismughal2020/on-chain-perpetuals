// SPDX-License-Identifier: Apache-2.0
//
// This program is a simplified implementation of an on-chain perpetuals DEX,
// drawing architectural and security patterns from audited protocols like
// Drift Protocol v2, Solana Perpetuals, and Openbook v2.
//
// MAIN ARCHITECTURAL REFERENCE: Drift Protocol v2
// - GitHub: https://github.com/drift-labs/protocol-v2/tree/master/programs/drift
// - Focus: Overall state management, risk engine, multi-liquidity mechanisms.
//
// SECONDARY REFERENCES:
// - Perpetuals Protocol: Core trading logic, atomic settlement.
// - Openbook v2: Order book and matching engine patterns.
//
// SECURITY FOCUS:
// - Position validation and robust margin requirements.
// - Atomic operations for trading and settlement.
// - Slippage protection and price impact controls.
// - Circuit breakers and time-based checks.
// - Comprehensive error handling and event emission.
// - Prevention of arithmetic overflows and reentrancy.
// - Strict validation of price feeds and user inputs.

use anchor_lang::prelude::*;
use anchor_lang::solana_program::clock::Clock;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};
use pyth_sdk_solana::load_price_feed_from_account_info;
use std::ops::Deref;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod perpetuals_dex {
    use super::*;

    /// Initializes the global state of the protocol.
    /// This is an admin-only function that sets up the main state account,
    /// fee structures, and the collateral mint.
    ///
    /// # Security
    /// - Access Control: Only the designated `admin` can call this.
    /// - Idempotency: The `init` constraint prevents re-initialization.
    pub fn initialize(
        ctx: Context<Initialize>,
        initial_base_spread: u32,
        initial_quote_asset_amount: u64,
        emergency_pause: bool,
    ) -> ProgramResult {
        let state = &mut ctx.accounts.state;
        state.admin = *ctx.accounts.admin.key;
        state.collateral_mint = *ctx.accounts.collateral_mint.to_account_info().key;
        state.collateral_vault = *ctx.accounts.collateral_vault.to_account_info().key;
        state.base_spread = initial_base_spread;
        state.quote_asset_amount = initial_quote_asset_amount;
        state.paused = emergency_pause;
        state.number_of_markets = 0;

        emit!(InitializeLog {
            admin: state.admin,
            ts: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Adds a new perpetual market to the protocol.
    /// This is an admin-only function.
    ///
    /// # Security
    /// - Access Control: The `state.admin == *admin.key` check ensures only the admin can add markets.
    /// - Input Validation: Checks are in place for market parameters.
    /// - Oracle Validation: Requires a valid Pyth oracle price feed account.
    ///
    /// # Implementation Note
    /// Inspired by Drift's `add_perp_market` instruction. The market structure holds
    /// all parameters related to a single perpetual contract (e.g., BTC-PERP).
    pub fn add_perp_market(
        ctx: Context<AddPerpMarket>,
        market_index: u16,
        amm_base_asset_reserve: u128,
        amm_quote_asset_reserve: u128,
        min_order_size: u64,
        max_position_size: u64,
    ) -> ProgramResult {
        // --- State Validation ---
        require!(
            ctx.accounts.state.number_of_markets == market_index,
            ErrorCode::MarketIndexAlreadyInitialized
        );
        require!(amm_base_asset_reserve > 0, ErrorCode::InvalidAmmReserve);
        require!(amm_quote_asset_reserve > 0, ErrorCode::InvalidAmmReserve);

        // --- Logic ---
        let market = &mut ctx.accounts.perp_market;
        market.market_index = market_index;
        market.amm_base_asset_reserve = amm_base_asset_reserve;
        market.amm_quote_asset_reserve = amm_quote_asset_reserve;
        market.min_order_size = min_order_size;
        market.max_position_size = max_position_size;
        market.oracle = *ctx.accounts.oracle.key;
        market.initialized = true;

        let state = &mut ctx.accounts.state;
        state.number_of_markets = state
            .number_of_markets
            .checked_add(1)
            .ok_or(ErrorCode::MathError)?;

        emit!(NewMarketLog {
            market_index,
            oracle: market.oracle,
            ts: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Initializes a new user account. This account will track the user's
    /// collateral, positions, and orders across all markets.
    ///
    /// # Implementation Note
    /// Drift uses a single `User` account that contains arrays for positions and orders.
    /// This pattern is efficient as it groups all of a user's state into one account,
    /// reducing the number of accounts that need to be loaded in a transaction.
    pub fn initialize_user(ctx: Context<InitializeUser>) -> ProgramResult {
        let user = &mut ctx.accounts.user;
        user.authority = *ctx.accounts.authority.key;
        user.collateral = 0;
        user.total_positions = 0;
        // Positions array is initialized to default values by Anchor `init`.

        emit!(NewUserLog {
            user: *ctx.accounts.user.to_account_info().key,
            authority: user.authority,
            ts: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Deposits collateral into the user's account.
    ///
    /// # Security
    /// - CPI Attack Prevention: Uses `anchor_spl::token` which provides checks against
    ///   cross-program invocation vulnerabilities.
    /// - Atomicity: The token transfer and state update occur in one atomic transaction.
    /// - Circuit Breaker: Checks if the protocol is paused.
    pub fn deposit_collateral(ctx: Context<UpdateCollateral>, amount: u64) -> ProgramResult {
        // --- Pre-checks ---
        require!(!ctx.accounts.state.paused, ErrorCode::ProtocolPaused);
        require!(amount > 0, ErrorCode::ZeroDeposit);

        // --- Token Transfer ---
        let cpi_accounts = Transfer {
            from: ctx.accounts.user_collateral_account.to_account_info(),
            to: ctx.accounts.collateral_vault.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, amount)?;

        // --- State Update ---
        let user = &mut ctx.accounts.user;
        user.collateral = user
            .collateral
            .checked_add(amount)
            .ok_or(ErrorCode::MathError)?;

        emit!(DepositLog {
            user: *ctx.accounts.user.to_account_info().key,
            amount,
            collateral_after: user.collateral,
            ts: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Withdraws collateral from the user's account.
    ///
    /// # Security
    /// - Margin Check: Critically, this function checks that the user still meets
    ///   maintenance margin requirements *after* the withdrawal. This prevents users
    ///   from withdrawing collateral needed to back their open positions. This is a
    ///   core security pattern from Drift.
    /// - Atomicity: Token transfer and state update are atomic.
    /// - Circuit Breaker: Checks if the protocol is paused.
    pub fn withdraw_collateral(ctx: Context<UpdateCollateral>, amount: u64) -> ProgramResult {
        // --- Pre-checks ---
        require!(!ctx.accounts.state.paused, ErrorCode::ProtocolPaused);
        require!(amount > 0, ErrorCode::ZeroWithdrawal);

        let user = &mut ctx.accounts.user;

        // --- Margin Validation ---
        let (total_collateral, margin_requirement) =
            math::margin::calculate_user_margin_requirement(user, &ctx.remaining_accounts)?;

        let free_collateral = total_collateral
            .checked_sub(margin_requirement)
            .ok_or(ErrorCode::InsufficientCollateral)?;

        require!(
            amount <= free_collateral,
            ErrorCode::InsufficientCollateral
        );

        // --- State Update ---
        user.collateral = user
            .collateral
            .checked_sub(amount)
            .ok_or(ErrorCode::MathError)?;

        // --- Token Transfer ---
        let state = &ctx.accounts.state;
        let seeds = &[b"state".as_ref(), &[state.bump]];
        let signer = &[&seeds[..]];

        let cpi_accounts = Transfer {
            from: ctx.accounts.collateral_vault.to_account_info(),
            to: ctx.accounts.user_collateral_account.to_account_info(),
            authority: ctx.accounts.state.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
        token::transfer(cpi_ctx, amount)?;

        emit!(WithdrawLog {
            user: *ctx.accounts.user.to_account_info().key,
            amount,
            collateral_after: user.collateral,
            ts: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Places a new perpetual order. This adds the order to the user's order list.
    /// The actual filling happens in a separate `fill_perp_order` instruction.
    ///
    /// # Security
    /// - Margin Check: Verifies the user has enough collateral to meet the *initial*
    ///   margin requirement for the new order.
    /// - Input Validation: Checks order parameters like size, price, and direction.
    /// - Slippage Protection: The `max_entry_price` acts as a slippage guard for the user.
    ///
    /// # Implementation Note
    /// This hybrid model supports both an on-chain AMM and an orderbook. This function
    /// conceptually places an order that can be matched against either.
    pub fn place_perp_order(
        ctx: Context<PlacePerpOrder>,
        order: OrderParams,
    ) -> ProgramResult {
        // --- Pre-checks ---
        require!(!ctx.accounts.state.paused, ErrorCode::ProtocolPaused);
        require!(
            order.base_asset_amount > ctx.accounts.perp_market.min_order_size,
            ErrorCode::OrderTooSmall
        );

        // --- Oracle Price Check ---
        let oracle_price_feed =
            load_price_feed_from_account_info(&ctx.accounts.oracle).map_err(|_| ErrorCode::InvalidOracle)?;
        let current_timestamp = Clock::get()?.unix_timestamp;
        // SECURITY: Prevents use of a stale oracle price for margin calculations.
        let oracle_price = oracle_price_feed
            .get_price_no_older_than(current_timestamp, 60)
            .ok_or(ErrorCode::OraclePriceStale)?;

        // --- Margin Validation (Initial Margin Requirement) ---
        // This is a simplified check. A full implementation would calculate the margin
        // impact of this specific order. Drift's engine is very sophisticated here.
        let (total_collateral, margin_requirement) =
            math::margin::calculate_user_margin_requirement(
                &ctx.accounts.user,
                &ctx.remaining_accounts,
            )?;

        let free_collateral = total_collateral
            .checked_sub(margin_requirement)
            .ok_or(ErrorCode::InsufficientCollateral)?;

        // Simplified check: new order notional value * initial margin ratio
        let notional_value = order.base_asset_amount
            .checked_mul(oracle_price.price as u64)
            .ok_or(ErrorCode::MathError)?;

        let new_order_margin_req = notional_value
            .checked_mul(constants::INITIAL_MARGIN_RATIO)
            .ok_or(ErrorCode::MathError)?
            .checked_div(constants::MARGIN_PRECISION)
            .ok_or(ErrorCode::MathError)?;

        require!(
            free_collateral >= new_order_margin_req,
            ErrorCode::InsufficientCollateralForOrder
        );

        // --- State Update ---
        let user = &mut ctx.accounts.user;
        user.add_order(order)?;

        emit!(OrderPlacedLog {
            user: *ctx.accounts.user.to_account_info().key,
            order,
            ts: current_timestamp,
        });

        Ok(())
    }

    /// Fills a perpetual order against the internal AMM.
    /// This is where the actual trade happens.
    ///
    /// # Security
    /// - Atomicity: All state changes (user position, AMM reserves, fee payments)
    ///   happen atomically. If any part fails, the entire transaction reverts.
    /// - Price Feed Validation: Ensures the oracle price is not stale before calculating trade prices.
    /// - Slippage Protection: The trade price is checked against the user's order price limit.
    ///
    /// # Implementation Note
    /// This function demonstrates filling against an AMM, a core feature of Drift's
    /// multi-liquidity mechanism. `math::amm::calculate_trade_price` would contain
    /// the x*y=k logic.
    pub fn fill_perp_order(
        ctx: Context<FillPerpOrder>,
        order_index: u8,
    ) -> ProgramResult {
        // --- Pre-checks ---
        require!(!ctx.accounts.state.paused, ErrorCode::ProtocolPaused);

        let clock = Clock::get()?;
        let user = &mut ctx.accounts.user;
        let market = &mut ctx.accounts.perp_market;

        // --- Get Order ---
        let order = user.get_order(order_index)?;

        // --- Oracle Price Check ---
        let oracle_price_feed =
            load_price_feed_from_account_info(&ctx.accounts.oracle).map_err(|_| ErrorCode::InvalidOracle)?;
        let oracle_price = oracle_price_feed
            .get_price_no_older_than(clock.unix_timestamp, 60)
            .ok_or(ErrorCode::OraclePriceStale)?;

        // --- AMM Trade Logic ---
        let (trade_price, new_base_reserve, new_quote_reserve) =
            math::amm::calculate_trade_price(
                order.base_asset_amount,
                order.direction,
                market.amm_base_asset_reserve,
                market.amm_quote_asset_reserve,
                oracle_price.price as u128,
            )?;

        // --- Slippage Check ---
        // Ensure the fill price is better than the user's specified limit price.
        match order.direction {
            PositionDirection::Long => require!(trade_price <= order.price, ErrorCode::SlippageExceeded),
            PositionDirection::Short => require!(trade_price >= order.price, ErrorCode::SlippageExceeded),
        }

        // --- Update User Position ---
        user.update_position(
            market.market_index,
            order.direction,
            order.base_asset_amount,
            trade_price,
        )?;

        // --- Update AMM State ---
        market.amm_base_asset_reserve = new_base_reserve;
        market.amm_quote_asset_reserve = new_quote_reserve;

        // --- Remove Order ---
        user.remove_order(order_index)?;

        // --- Margin Check (Post-Trade) ---
        // A full implementation would check the user's margin again here.

        emit!(TradeLog {
            user: *ctx.accounts.user.to_account_info().key,
            market_index: market.market_index,
            direction: order.direction,
            base_asset_amount: order.base_asset_amount,
            quote_asset_amount: order.base_asset_amount
                .checked_mul(trade_price as u64)
                .ok_or(ErrorCode::MathError)?,
            fill_price: trade_price,
            ts: clock.unix_timestamp,
        });

        Ok(())
    }

    /// Liquidates a user's perpetual position if their margin ratio falls below
    /// the maintenance margin requirement.
    ///
    /// # Security
    /// - Margin Check: The core of the function. It verifies that the user is actually
    ///   liquidatable by comparing their total collateral to their margin requirement.
    /// - Price Feed Validation: Uses a fresh oracle price for the calculation.
    /// - Incentives: The liquidator (the caller) receives a portion of the liquidated
    ///   user's collateral as a reward, incentivizing third parties to maintain
    ///   protocol health. This is a standard pattern in DeFi.
    pub fn liquidate_perp(ctx: Context<LiquidatePerp>) -> ProgramResult {
        // --- Pre-checks ---
        require!(!ctx.accounts.state.paused, ErrorCode::ProtocolPaused);

        let user_to_liquidate = &mut ctx.accounts.user_to_liquidate;
        let liquidator_user = &mut ctx.accounts.liquidator_user;

        // --- Margin Validation ---
        let (total_collateral, margin_requirement) =
            math::margin::calculate_user_margin_requirement(
                user_to_liquidate,
                &ctx.remaining_accounts,
            )?;

        // SECURITY: Crucial check. We can only liquidate if collateral is below requirement.
        require!(
            total_collateral < margin_requirement,
            ErrorCode::UserNotLiquidatable
        );

        // --- Liquidation Logic ---
        // Simplified: close the user's largest position and transfer penalty.
        // A full implementation (like Drift's) would be more complex, potentially
        // partially liquidating or handling socialized losses.

        if let Some(position_to_liquidate) = user_to_liquidate.get_largest_position() {
            // Assume closing the position at the current oracle price
            let oracle_price_feed = load_price_feed_from_account_info(&ctx.accounts.oracle)
                .map_err(|_| ErrorCode::InvalidOracle)?;
            let oracle_price = oracle_price_feed
                .get_price_no_older_than(Clock::get()?.unix_timestamp, 60)
                .ok_or(ErrorCode::OraclePriceStale)?;

            let pnl = math::pnl::calculate_pnl(
                position_to_liquidate,
                oracle_price.price as u128,
            )?;

            // Apply PnL to user's collateral
            user_to_liquidate.collateral = (user_to_liquidate.collateral as i128 + pnl) as u64;

            // Calculate penalty
            let penalty = (position_to_liquidate.base_asset_amount as u128)
                .checked_mul(oracle_price.price as u128)
                .ok_or(ErrorCode::MathError)?
                .checked_mul(constants::LIQUIDATION_PENALTY_NUMERATOR)
                .ok_or(ErrorCode::MathError)?
                .checked_div(constants::LIQUIDATION_PENALTY_DENOMINATOR)
                .ok_or(ErrorCode::MathError)? as u64;

            // Transfer penalty
            user_to_liquidate.collateral = user_to_liquidate.collateral.checked_sub(penalty).ok_or(ErrorCode::MathError)?;
            liquidator_user.collateral = liquidator_user.collateral.checked_add(penalty).ok_or(ErrorCode::MathError)?;

            // Close the position
            user_to_liquidate.remove_position(position_to_liquidate.market_index);

            emit!(LiquidationLog {
                liquidator: *ctx.accounts.liquidator.key,
                liquidated_user: *user_to_liquidate.to_account_info().key,
                penalty,
                ts: Clock::get()?.unix_timestamp,
            });

        } else {
            return Err(ErrorCode::NoPositionsToLiquidate.into());
        }

        Ok(())
    }

    /// Toggles the protocol's emergency pause state. Admin only.
    ///
    /// # Security
    /// - Access Control: Enforces admin-only access.
    /// - Circuit Breaker Pattern: This function is the control switch for the circuit
    ///   breaker checks implemented in critical instructions like `deposit`, `withdraw`,
    ///   `place_order`, etc. It's a vital safety mechanism.
    pub fn toggle_emergency_pause(ctx: Context<AdminUpdate>) -> ProgramResult {
        ctx.accounts.state.paused = !ctx.accounts.state.paused;
        Ok(())
    }
}

// ----------------------------------------------------------------------------
// Instructions Contexts
// ----------------------------------------------------------------------------

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(
        init,
        payer = admin,
        space = 8 + std::mem::size_of::<State>(),
        seeds = [b"state".as_ref()],
        bump
    )]
    pub state: Account<'info, State>,
    pub collateral_mint: Account<'info, Mint>,
    #[account(
        init,
        payer = admin,
        token::mint = collateral_mint,
        token::authority = state,
        seeds = [b"collateral_vault".as_ref()],
        bump
    )]
    pub collateral_vault: Account<'info, TokenAccount>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
#[instruction(market_index: u16)]
pub struct AddPerpMarket<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(
        mut,
        has_one = admin @ ErrorCode::AdminAccessOnly
    )]
    pub state: Account<'info, State>,
    #[account(
        init,
        payer = admin,
        space = 8 + std::mem::size_of::<PerpMarket>(),
        seeds = [b"perp_market".as_ref(), market_index.to_le_bytes().as_ref()],
        bump
    )]
    pub perp_market: Account<'info, PerpMarket>,
    /// CHECK: Oracle account validated in the instruction logic
    pub oracle: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitializeUser<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        init,
        payer = authority,
        space = 8 + std::mem::size_of::<User>(),
        seeds = [b"user".as_ref(), authority.key().as_ref()],
        bump
    )]
    pub user: Account<'info, User>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateCollateral<'info> {
    pub authority: Signer<'info>,
    #[account(
        mut,
        has_one = authority @ ErrorCode::UserAuthorityMismatch
    )]
    pub user: Account<'info, User>,
    #[account(
        mut,
        seeds = [b"state".as_ref()],
        bump = state.bump
    )]
    pub state: Account<'info, State>,
    #[account(
        mut,
        seeds = [b"collateral_vault".as_ref()],
        bump = state.vault_bump
    )]
    pub collateral_vault: Account<'info, TokenAccount>,
    #[account(
        mut,
        constraint = user_collateral_account.mint == state.collateral_mint
    )]
    pub user_collateral_account: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct PlacePerpOrder<'info> {
    pub authority: Signer<'info>,
    #[account(
        mut,
        has_one = authority @ ErrorCode::UserAuthorityMismatch
    )]
    pub user: Account<'info, User>,
    pub state: Account<'info, State>,
    #[account(
        seeds = [b"perp_market".as_ref(), perp_market.market_index.to_le_bytes().as_ref()],
        bump = perp_market.bump
    )]
    pub perp_market: Account<'info, PerpMarket>,
    #[account(
        constraint = oracle.key() == perp_market.oracle @ ErrorCode::InvalidOracle
    )]
    /// CHECK: Oracle account validated by constraint and in logic.
    pub oracle: AccountInfo<'info>,
}

#[derive(Accounts)]
#[instruction(order_index: u8)]
pub struct FillPerpOrder<'info> {
    // The filler can be anyone, incentivizing a decentralized matching engine.
    pub filler: Signer<'info>,
    #[account(mut)]
    pub user: Account<'info, User>,
    pub state: Account<'info, State>,
    #[account(
        mut,
        seeds = [b"perp_market".as_ref(), perp_market.market_index.to_le_bytes().as_ref()],
        bump = perp_market.bump
    )]
    pub perp_market: Account<'info, PerpMarket>,
    #[account(
        constraint = oracle.key() == perp_market.oracle @ ErrorCode::InvalidOracle
    )]
    /// CHECK: Oracle account validated by constraint and in logic.
    pub oracle: AccountInfo<'info>,
}


#[derive(Accounts)]
pub struct LiquidatePerp<'info> {
    pub liquidator: Signer<'info>,
    #[account(
        mut,
        has_one = authority @ ErrorCode::UserAuthorityMismatch
    )]
    pub liquidator_user: Account<'info, User>,
    #[account(mut)]
    pub user_to_liquidate: Account<'info, User>,
    pub state: Account<'info, State>,
    /// CHECK: Oracle account validated in logic. Passed in remaining_accounts.
    pub oracle: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct AdminUpdate<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(
        mut,
        has_one = admin @ ErrorCode::AdminAccessOnly
    )]
    pub state: Account<'info, State>,
}


// ----------------------------------------------------------------------------
// State Accounts
// ----------------------------------------------------------------------------

#[account]
#[derive(Default)]
pub struct State {
    pub admin: Pubkey,
    pub collateral_mint: Pubkey,
    pub collateral_vault: Pubkey,
    pub base_spread: u32,
    pub quote_asset_amount: u64,
    pub paused: bool,
    pub number_of_markets: u16,
    pub bump: u8,
    pub vault_bump: u8,
}

#[account]
#[derive(Default)]
pub struct PerpMarket {
    pub initialized: bool,
    pub market_index: u16,
    pub oracle: Pubkey,
    // AMM state
    pub amm_base_asset_reserve: u128,
    pub amm_quote_asset_reserve: u128,
    // Risk parameters
    pub min_order_size: u64,
    pub max_position_size: u64,
    // Fees, funding rates etc. would go here
    pub bump: u8,
}

#[account]
#[derive(Default)]
pub struct User {
    pub authority: Pubkey,
    pub collateral: u64,
    pub positions: [PerpPosition; 10], // Max 10 positions
    pub orders: [Order; 10],          // Max 10 open orders
    pub total_positions: u8,
    pub total_orders: u8,
    pub bump: u8,
}

// ----------------------------------------------------------------------------
// Data Structs (Not stored in separate accounts)
// ----------------------------------------------------------------------------

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Default, Copy)]
pub struct PerpPosition {
    pub market_index: u16,
    pub base_asset_amount: u64,
    pub quote_asset_amount: u64, // Represents the entry value of the position
    pub last_cumulative_funding_rate: i128,
    pub direction: PositionDirection,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Default, Copy)]
pub struct Order {
    pub market_index: u16,
    pub direction: PositionDirection,
    pub base_asset_amount: u64,
    pub price: u64, // Limit price
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy)]
pub struct OrderParams {
    pub market_index: u16,
    pub direction: PositionDirection,
    pub base_asset_amount: u64,
    pub price: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq, Copy, Default)]
pub enum PositionDirection {
    #[default]
    Long,
    Short,
}

// ----------------------------------------------------------------------------
// User Account Logic
// ----------------------------------------------------------------------------
// IMPLEMENTATION NOTE: These methods are attached to the `User` struct for
// organized logic, similar to how Drift structures its state methods. This makes
// the core instruction logic cleaner and easier to read.

impl User {
    pub fn add_order(&mut self, order: OrderParams) -> ProgramResult {
        if self.total_orders >= 10 {
            return Err(ErrorCode::MaxOrdersReached.into());
        }
        self.orders[self.total_orders as usize] = Order {
            market_index: order.market_index,
            direction: order.direction,
            base_asset_amount: order.base_asset_amount,
            price: order.price,
        };
        self.total_orders += 1;
        Ok(())
    }

    pub fn get_order(&self, order_index: u8) -> Result<Order> {
        if order_index >= self.total_orders {
            return Err(ErrorCode::InvalidOrderIndex.into());
        }
        Ok(self.orders[order_index as usize])
    }

    pub fn remove_order(&mut self, order_index: u8) -> ProgramResult {
        if order_index >= self.total_orders {
            return Err(ErrorCode::InvalidOrderIndex.into());
        }
        // Swap remove
        self.orders[order_index as usize] = self.orders[(self.total_orders - 1) as usize];
        self.orders[(self.total_orders - 1) as usize] = Order::default();
        self.total_orders -= 1;
        Ok(())
    }

    pub fn update_position(
        &mut self,
        market_index: u16,
        direction: PositionDirection,
        base_amount: u64,
        trade_price: u128,
    ) -> ProgramResult {
        let quote_amount = (base_amount as u128)
            .checked_mul(trade_price)
            .ok_or(ErrorCode::MathError)? as u64;

        if let Some(position) = self
            .positions
            .iter_mut()
            .find(|p| p.market_index == market_index)
        {
            // Position exists, update it
            if position.direction == direction {
                // Increasing position size
                position.base_asset_amount = position
                    .base_asset_amount
                    .checked_add(base_amount)
                    .ok_or(ErrorCode::MathError)?;
                position.quote_asset_amount = position
                    .quote_asset_amount
                    .checked_add(quote_amount)
                    .ok_or(ErrorCode::MathError)?;
            } else {
                // Reducing or flipping position
                if base_amount > position.base_asset_amount {
                    // Flip direction
                    position.direction = direction;
                    position.base_asset_amount = base_amount
                        .checked_sub(position.base_asset_amount)
                        .ok_or(ErrorCode::MathError)?;
                    position.quote_asset_amount = quote_amount
                        .checked_sub(position.quote_asset_amount)
                        .ok_or(ErrorCode::MathError)?;
                } else {
                    // Reduce size
                    position.base_asset_amount = position
                        .base_asset_amount
                        .checked_sub(base_amount)
                        .ok_or(ErrorCode::MathError)?;
                    position.quote_asset_amount = position
                        .quote_asset_amount
                        .checked_sub(quote_amount)
                        .ok_or(ErrorCode::MathError)?;
                }
            }
        } else {
            // New position
            if self.total_positions >= 10 {
                return Err(ErrorCode::MaxPositionsReached.into());
            }
            self.positions[self.total_positions as usize] = PerpPosition {
                market_index,
                direction,
                base_asset_amount: base_amount,
                quote_asset_amount: quote_amount,
                last_cumulative_funding_rate: 0,
            };
            self.total_positions += 1;
        }

        Ok(())
    }

    pub fn get_largest_position(&self) -> Option<PerpPosition> {
        self.positions
            .iter()
            .filter(|p| p.base_asset_amount > 0)
            .max_by_key(|p| p.base_asset_amount)
            .copied()
    }

    pub fn remove_position(&mut self, market_index: u16) {
        if let Some(index) = self.positions.iter().position(|p| p.market_index == market_index) {
            // Swap remove
            self.positions[index] = self.positions[(self.total_positions - 1) as usize];
            self.positions[(self.total_positions - 1) as usize] = PerpPosition::default();
            self.total_positions -= 1;
        }
    }
}


// ----------------------------------------------------------------------------
// Math Module
// ----------------------------------------------------------------------------
// SECURITY NOTE: A dedicated math module is crucial for safety. All arithmetic
// that can overflow/underflow should be done using `checked_` methods. Using
// higher precision types like `u128` for intermediate calculations helps
// prevent precision loss, a pattern seen extensively in Drift.

pub mod math {
    use super::*;

    pub mod margin {
        use super::*;

        // This is the core of the risk engine. It calculates the total value of a user's
        // assets and the total risk of their positions.
        pub fn calculate_user_margin_requirement(
            user: &Account<User>,
            remaining_accounts: &[AccountInfo],
        ) -> Result<(u64, u64)> {
            let mut total_collateral_value = user.collateral;
            let mut total_margin_requirement = 0_u64;
            let mut account_info_iter = remaining_accounts.iter();

            // Calculate PnL from all open positions
            for position in user.positions.iter().filter(|p| p.base_asset_amount > 0) {
                let market_account_info = next_account_info(&mut account_info_iter)?;
                let oracle_account_info = next_account_info(&mut account_info_iter)?;

                // Deserialize market to get oracle key
                let market = Account::<PerpMarket>::try_from(market_account_info)?;
                require!(oracle_account_info.key == &market.oracle, ErrorCode::InvalidOracleForMarket);

                // Get current oracle price
                let oracle_price_feed = load_price_feed_from_account_info(oracle_account_info).map_err(|_| ErrorCode::InvalidOracle)?;
                let oracle_price = oracle_price_feed.get_price_no_older_than(Clock::get()?.unix_timestamp, 60)
                    .ok_or(ErrorCode::OraclePriceStale)?;

                // Calculate PnL and add to collateral value
                let pnl = pnl::calculate_pnl(position, oracle_price.price as u128)?;
                total_collateral_value = (total_collateral_value as i128 + pnl) as u64;

                // Calculate margin requirement for this position
                let position_notional_value = (position.base_asset_amount as u128)
                    .checked_mul(oracle_price.price as u128).ok_or(ErrorCode::MathError)? as u64;

                let requirement = position_notional_value
                    .checked_mul(constants::MAINTENANCE_MARGIN_RATIO).ok_or(ErrorCode::MathError)?
                    .checked_div(constants::MARGIN_PRECISION).ok_or(ErrorCode::MathError)?;

                total_margin_requirement = total_margin_requirement.checked_add(requirement).ok_or(ErrorCode::MathError)?;
            }

            Ok((total_collateral_value, total_margin_requirement))
        }
    }

    pub mod pnl {
        use super::*;
        // PnL = (current_price - entry_price) * base_amount * direction
        pub fn calculate_pnl(position: &PerpPosition, current_price: u128) -> Result<i128> {
            if position.base_asset_amount == 0 {
                return Ok(0);
            }
            let entry_price = (position.quote_asset_amount as u128)
                .checked_div(position.base_asset_amount as u128).ok_or(ErrorCode::MathError)?;

            let price_diff = current_price as i128 - entry_price as i128;
            let pnl = (price_diff)
                .checked_mul(position.base_asset_amount as i128).ok_or(ErrorCode::MathError)?;

            match position.direction {
                PositionDirection::Long => Ok(pnl),
                PositionDirection::Short => Ok(pnl.checked_mul(-1).ok_or(ErrorCode::MathError)?),
            }
        }
    }

    pub mod amm {
        use super::*;
        // Simplified AMM logic based on x*y=k. Drift uses a more advanced virtual AMM.
        pub fn calculate_trade_price(
            base_amount: u64,
            direction: PositionDirection,
            base_reserve: u128,
            quote_reserve: u128,
            _oracle_price: u128, // Oracle price is used for pegging/rebalancing in a full implementation
        ) -> Result<(u128, u128, u128)> {
            let k = base_reserve.checked_mul(quote_reserve).ok_or(ErrorCode::MathError)?;

            let (new_base_reserve, new_quote_reserve) = match direction {
                PositionDirection::Long => { // User buys base, adds quote
                    let new_base = base_reserve.checked_sub(base_amount as u128).ok_or(ErrorCode::AmmNotEnoughLiquidity)?;
                    let new_quote = k.checked_div(new_base).ok_or(ErrorCode::MathError)?;
                    (new_base, new_quote)
                },
                PositionDirection::Short => { // User sells base, removes quote
                    let new_base = base_reserve.checked_add(base_amount as u128).ok_or(ErrorCode::MathError)?;
                    let new_quote = k.checked_div(new_base).ok_or(ErrorCode::MathError)?;
                    (new_base, new_quote)
                },
            };

            let quote_amount_traded = if quote_reserve > new_quote_reserve {
                quote_reserve.checked_sub(new_quote_reserve).ok_or(ErrorCode::MathError)?
            } else {
                new_quote_reserve.checked_sub(quote_reserve).ok_or(ErrorCode::MathError)?
            };

            let trade_price = quote_amount_traded.checked_div(base_amount as u128).ok_or(ErrorCode::MathError)?;

            Ok((trade_price, new_base_reserve, new_quote_reserve))
        }
    }
}

// ----------------------------------------------------------------------------
// Constants
// ----------------------------------------------------------------------------
pub mod constants {
    pub const MARGIN_PRECISION: u64 = 1_000_000; // 10^6
    pub const INITIAL_MARGIN_RATIO: u64 = 100_000; // 10%
    pub const MAINTENANCE_MARGIN_RATIO: u64 = 50_000; // 5%
    pub const LIQUIDATION_PENALTY_NUMERATOR: u128 = 1;
    pub const LIQUIDATION_PENALTY_DENOMINATOR: u128 = 100; // 1%
}


// ----------------------------------------------------------------------------
// Events
// ----------------------------------------------------------------------------
// IMPLEMENTATION NOTE: Emitting detailed events for every significant state
// change is a best practice from Drift. It allows off-chain services to easily
// index and reconstruct the protocol's history.

#[event]
pub struct InitializeLog {
    pub admin: Pubkey,
    pub ts: i64,
}

#[event]
pub struct NewMarketLog {
    pub market_index: u16,
    pub oracle: Pubkey,
    pub ts: i64,
}

#[event]
pub struct NewUserLog {
    pub user: Pubkey,
    pub authority: Pubkey,
    pub ts: i64,
}

#[event]
pub struct DepositLog {
    pub user: Pubkey,
    pub amount: u64,
    pub collateral_after: u64,
    pub ts: i64,
}

#[event]
pub struct WithdrawLog {
    pub user: Pubkey,
    pub amount: u64,
    pub collateral_after: u64,
    pub ts: i64,
}

#[event]
pub struct OrderPlacedLog {
    pub user: Pubkey,
    pub order: OrderParams,
    pub ts: i64,
}

#[event]
pub struct TradeLog {
    pub user: Pubkey,
    pub market_index: u16,
    pub direction: PositionDirection,
    pub base_asset_amount: u64,
    pub quote_asset_amount: u64,
    pub fill_price: u128,
    pub ts: i64,
}

#[event]
pub struct LiquidationLog {
    pub liquidator: Pubkey,
    pub liquidated_user: Pubkey,
    pub penalty: u64,
    pub ts: i64,
}


// ----------------------------------------------------------------------------
// Error Codes
// ----------------------------------------------------------------------------
// SECURITY NOTE: Using a detailed error enum like Drift's `DriftErrorCode` is
// essential for client-side debugging and on-chain program analysis. Each
// potential failure point should have a unique error code.

#[error_code]
pub enum ErrorCode {
    #[msg("Protocol is currently paused by admin.")]
    ProtocolPaused,
    #[msg("Admin access only.")]
    AdminAccessOnly,
    #[msg("User does not match authority.")]
    UserAuthorityMismatch,
    #[msg("Mathematical operation resulted in an error.")]
    MathError,
    #[msg("Deposit amount must be greater than zero.")]
    ZeroDeposit,
    #[msg("Withdrawal amount must be greater than zero.")]
    ZeroWithdrawal,
    #[msg("Insufficient collateral to perform this action.")]
    InsufficientCollateral,
    #[msg("Insufficient free collateral to place this order.")]
    InsufficientCollateralForOrder,
    #[msg("Market index has already been initialized.")]
    MarketIndexAlreadyInitialized,
    #[msg("Invalid AMM reserve amounts.")]
    InvalidAmmReserve,
    #[msg("Order size is below the market's minimum.")]
    OrderTooSmall,
    #[msg("Oracle price feed is stale.")]
    OraclePriceStale,
    #[msg("Invalid Pyth oracle account provided.")]
    InvalidOracle,
    #[msg("Oracle provided does not match the market's oracle.")]
    InvalidOracleForMarket,
    #[msg("User has reached the maximum number of open orders.")]
    MaxOrdersReached,
    #[msg("User has reached the maximum number of positions.")]
    MaxPositionsReached,
    #[msg("The specified order index is invalid.")]
    InvalidOrderIndex,
    #[msg("Trade would cause excessive slippage.")]
    SlippageExceeded,
    #[msg("The AMM does not have enough liquidity to fill the order.")]
    AmmNotEnoughLiquidity,
    #[msg("This user's position is not eligible for liquidation.")]
    UserNotLiquidatable,
    #[msg("User has no open positions to liquidate.")]
    NoPositionsToLiquidate,
}
